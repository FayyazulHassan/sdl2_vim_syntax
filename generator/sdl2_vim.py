#!/usr/bin/env python3

import re
from argparse import ArgumentParser
from pathlib import Path

from pycparser import c_ast, parse_file, preprocess_file


class SDLVisitor(c_ast.NodeVisitor):
    __slots__ = ["functions", "types", "enums", "defines"]

    def __init__(self) -> None:
        self.functions = []
        self.types = []
        self.enums = []
        self.defines = []

    def visit_FuncDecl(self, node: c_ast.FuncDecl) -> None:
        t = None
        if isinstance(node.type, c_ast.TypeDecl):
            t = node.type
        elif isinstance(node.type, c_ast.PtrDecl):
            t = node.type.type

        if t is not None:
            if t.declname.startswith("SDL_"):
                self.functions.append(t.declname)

    def visit_TypeDecl(self, node: c_ast.TypeDecl) -> None:
        if isinstance(node.type, c_ast.Enum):
            self.visit_Enum(node.type)

        if (
            isinstance(node.declname, str)
            and len(node.declname) > 4
            and node.declname.startswith(("SDL_", "Sint", "Uint"))
        ):
            self.types.append(node.declname)

    def visit_Enumerator(self, node: c_ast.Enumerator) -> None:
        if node.name.startswith("SDL"):
            self.enums.append(node.name)

    def visit_Enum(self, node: c_ast.Enum) -> None:
        for v in node.values.enumerators:
            self.visit_Enumerator(v)

    def process_defines(self, defines: list[str]):
        identifier_pat = "SDL_[_a-zA-Z0-9]{0,30}"
        parameters_pat = r"\([^)]\)"
        replacement_list_pat = r"(?<=\s).*"
        macro_pat = re.compile(
            rf"#define ({identifier_pat})({parameters_pat})?\s*({replacement_list_pat})?"
        )

        for s in defines:
            if (m := macro_pat.fullmatch(s)) is not None:
                identifier = m.group(1)
                has_parameters = m.group(2) is not None
                replacement = m.group(3)

                if has_parameters or replacement in self.functions:
                    self.functions.append(identifier)

                elif replacement in self.types:
                    self.types.append(identifier)

                elif replacement in self.enums:
                    self.enums.append(identifier)

                else:
                    # no params, no replacement or it is not an existing symbol
                    self.defines.append(identifier)


def generate_output(
    filename: str | bytes | Path, visitor: SDLVisitor, sdl_version: str
) -> None:
    with open(filename, "wt") as f:
        f.write(
            f"""\
" Vim syntax file
" Language: C SDL2 library extension
" Generated By: sdl2_vim.py
" Version: {sdl_version}

syn keyword sdl2_function {" ".join(visitor.functions)}
syn keyword sdl2_enum {" ".join(visitor.enums)}
syn keyword sdl2_type {" ".join(visitor.types)}
syn keyword sdl2_define {" ".join(visitor.defines)}

" Default highlighting
if version >= 508
  if version < 508
    command -nargs=+ HiLink hi link <args>
  else
    command -nargs=+ HiLink hi def link <args>
  endif
  HiLink sdl2_function Function
  HiLink sdl2_type Type
  HiLink sdl2_enum Constant
  HiLink sdl2_define Constant
  delcommand HiLink
endif
"""
        )


def get_sdl_version(filename: str | bytes | Path) -> str:
    # search for SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL
    pat = re.compile(
        r"^#define\s+SDL_(MAJOR_VERSION|MINOR_VERSION|PATCHLEVEL)\s+([0-9]+)$"
    )
    version_major = None
    version_minor = None
    version_patchlevel = None
    with open(filename) as f:
        while (line := f.readline()) and (
            version_major is None or version_minor is None or version_patchlevel is None
        ):
            if m := pat.match(line):
                version_type = m.group(1)
                version_number = m.group(2)
                if version_type == "MAJOR_VERSION":
                    version_major = version_number
                elif version_type == "MINOR_VERSION":
                    version_minor = version_number
                elif version_type == "PATCHLEVEL":
                    version_patchlevel = version_number

    return f"{version_major}.{version_minor}.{version_patchlevel}"


def process_file(filename: str | bytes | Path, inc_path: Path) -> None:
    sdl_version = get_sdl_version(inc_path.joinpath("SDL_version.h"))

    cpp_args = [
        "-Iutils/fake_libc_include",
        f"-I{inc_path}",
        "-DDECLSPEC=",
        "-D_SDL_platform_h=1",
        "-D_SDL_endian_h=1",
        "-DSDL_FORCE_INLINE=",
        "-D__attribute__(x)=",
    ]
    ast = parse_file(filename, use_cpp=True, cpp_args=cpp_args)
    visitor = SDLVisitor()
    visitor.visit(ast)

    cpp_args.append("-dM")
    defines_text = preprocess_file(filename, cpp_args=cpp_args)
    visitor.process_defines(defines_text.splitlines())

    generate_output("sdl2.vim", visitor, sdl_version)


arg_parser = ArgumentParser()
arg_parser.add_argument("inc_path", type=Path, help="path/to/SDL2/headers/directory")

if __name__ == "__main__":
    args = arg_parser.parse_args()

    process_file(args.inc_path.joinpath("SDL.h"), args.inc_path)
